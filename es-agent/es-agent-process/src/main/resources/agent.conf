include "plugins"

eventstreams {

  agent {

    name = "agent1"
    description = "desc"
    location = "loc1"

    debug {
      lifecycle = on
    }

    hq {
      endpoint = "akka.tcp://engine@localhost:2551/user/agents"
    }
  }

  storage {
    directory = "."
    directory = ${?NUGGET_AGENT_HOME}

    db = "storage"

    provider = "eventstreams.core.storage.H2Storage"
  }

}


akka {
  extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  event-handlers = ["akka.event.slf4j.Slf4jEventHandler"]
  loglevel = "INFO"
  stdout-loglevel = "OFF"

  actor {
    provider = "akka.remote.RemoteActorRefProvider"

    debug {
      lifecycle = on
    }

    serializers {
//      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }
    serialization-bindings {
//      "eventstreams.CommMessage" = kryo
    }
    kryo  {
      # Possibles values for type are: graph or nograph  
      # graph supports serialization of object graphs with shared nodes  
      # and cyclic references, but this comes at the expense of a small overhead  
      # nograph does not support object grpahs with shared nodes, but is usually faster   
      type = "graph"


      # Possible values for idstrategy are:  
      # default, explicit, incremental  
      #  
      # default - slowest and produces bigger serialized representation. Contains fully-  
      # qualified class names (FQCNs) for each class. Note that selecting this strategy 
      # does not work in version 0.3.2, but is available on master and from 0.3.3 onward.
      #  
      # explicit - fast and produces compact serialized representation. Requires that all  
      # classes that will be serialized are pre-registered using the "mappings" and "classes"
      # sections. To guarantee that both sender and receiver use the same numeric ids for the same  
      # classes it is advised to provide exactly the same entries in the "mappings" section   
      #  
      # incremental - fast and produces compact serialized representation. Support optional  
      # pre-registering of classes using the "mappings" and "classes" sections. If class is  
      # not pre-registered, it will be registered dynamically by picking a next available id  
      # To guarantee that both sender and receiver use the same numeric ids for the same   
      # classes it is advised to pre-register them using at least the "classes" section   

      idstrategy = "incremental"

      # Define a default size for serializer pool
      # Try to define the size to be at least as big as the max possible number
      # of threads that may be used for serialization, i.e. max number
      # of threads allowed for the scheduler
      serializer-pool-size = 16

      # Define a default size for byte buffers used during serialization   
      buffer-size = 4096

      # The serialization byte buffers are doubled as needed until they exceed max-buffer-size and an exception is thrown. Can be -1 for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # Enable transparent compression of serialized messages
      # accepted values are: off | lz4 | deflate
      compression = lz4

      # Log implicitly registered classes. Useful, if you want to know all classes
      # which are serialized. You can then use this information in the mappings and/or 
      # classes sections
      implicit-registration-logging = true

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If proviced, Kryo uses the class specified by a fully qualified class name
      # to perform a custom initialization of Kryo instances in addition to what
      # is done automatically based on the config file.
      #kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"
      classes = [
        "eventstreams.ProducedMessage",
        "eventstreams.TopicKey",
        "eventstreams.ComponentKey",
        "eventstreams.LocalSubj",
        "eventstreams.RemoteAddrSubj",
        "eventstreams.Subscribe",
        "eventstreams.Unsubscribe",
        "eventstreams.Command",
        "eventstreams.Update",
        "eventstreams.CommandOk",
        "eventstreams.CommandErr",
        "eventstreams.Stale",
        "eventstreams.RegisterComponent",
        "akka.actor.RepointableActorRef",
        "eventstreams.Acknowledgeable",
        "eventstreams.AcknowledgeAsProcessed",
        "eventstreams.AcknowledgeAsReceived",
        "eventstreams.core.agent.core.GateClosed",
        "eventstreams.core.agent.core.GateOpen",
        "eventstreams.core.agent.core.GateStateCheck",
        "eventstreams.core.agent.core.GateStateUpdate",
        "eventstreams.core.agent.core.Handshake",
        "eventstreams.core.agent.core.CommunicationProxyRef",
        "eventstreams.core.agent.core.CreateEventsource",
        "eventstreams.core.agent.core.ReconfigureEventsource",
        "eventstreams.core.agent.core.RemoveEventsource",
        "eventstreams.core.agent.core.ResetEventsourceState",
        "eventstreams.core.actors.ClusterPeerHandshake",
        "eventstreams.core.actors.ClusterPeerHandshakeResponse",

        "akka.actor.LocalActorRef",
        "scala.collection.immutable.Nil$",
        "scala.collection.mutable.ListBuffer",
        "scala.Some",
        "scala.None",
        "eventstreams.EventFrame",
        "scala.collection.immutable.Map$EmptyMap$",

        "play.api.libs.json.JsObject",
        "scala.collection.mutable.ArrayBuffer",
        "scala.Tuple2",
        "play.api.libs.json.JsString",
        "play.api.libs.json.JsArray",
        "scala.collection.immutable.$colon$colon",

        "play.api.libs.json.JsBoolean",
        "play.api.libs.json.JsNumber",
        "scala.math.BigDecimal",
        "java.math.BigDecimal",
        "java.math.MathContext",
        "java.math.RoundingMode"

      ]

    }  
  
  }
  
  remote {
    log-remote-lifecycle-events = off
    enabled-transports = ["akka.remote.netty.tcp"]
    netty.tcp {
      hostname = "localhost"
      port = 2553
    }
  }
}